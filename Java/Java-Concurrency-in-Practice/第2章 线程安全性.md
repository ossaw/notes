## 第2章 线程安全性

> 构建稳健的并发程序必须正确使用线程和锁, 其核心在于对状态访问操作进行管理, 特别是共享的和可变的状态的访问.
> 共享意味着可以有多个线程同时访问(通常是对象实例域, 静态域), 可变意味着变量的值再起生命周期内可以发生变化.

1. Java中同步机制包括关键字synchronized, volatile, 显示锁(java.util.concurrent.lock包内), 原子变量(java.util.concurrent.atomic包内).

2. 如果某个并发程序缺少必要的同步机制并且看上去似乎能正确执行, 但程序仍可能在某个时刻发生错误(活跃性风险).

3. 如果多个程序访问可变状态变量时没有使用合适的同步, 那么程序就会出现错误, 有三种方式可以修复: 
不在程序中共享该变量(例如将其变为局部变量)
将状态变量修改为不可变得变量(多线程只能读取而不能修改)
在访问变量时使用同步机制

4. 程序的封装性越好越容易实现程序的线程安全性, 在设计线程安全的类时, 良好的面向对象技术, 不可修改性, 以及明晰的不可变性规范都能起到一定的帮助作用.

5. 在编写并发应用程序时, 一种正确的编程方法是: 首先使代码正确运行, 然后在提高代码的速度, 即便如此, 最好也只是当性能测试结果和应用需求告诉你必须提高性能, 以及测试结果表明这种优化在实际环境中确实能带来性能提升时, 才进行优化.

6. 完全由线程安全的类构成的程序并不一定就是线程安全的, 而在线程安全的类中也可以包含非线程安全的类.

### 2.1 什么是线程安全性

> 当多个线程访问某个类时, 不管运行时环境采用何种调度方式或者这些线程将如何交替执行, 并且在主调代码中不需要任何额外的同步或协同, 这个累都能表现出正确的行为(也就是与其规范一致的行为), 那么就称这个类是线程安全的.

1. 在线程安全的类中封装了必要的同步机制, 因此客户端无须进一步采取同步措施, 但是当客户端想要保证调用线程安全类的两个方法的原子性时, 需要使用外部同步.

2. 无状态对象一定是线程安全的.

3. 局部变量不在线程之间共享, 因此不需要同步.

### 2.2 原子性

#### 2.2.1 竞态条件

> 竞态条件: 由于不恰当的执行时序出现不正确的执行结果.

1. 最常见的竞态条件就是先检查后执行操作, 即通过一个可能失效的观测结果来决定下一步操作, 也就说说正确的结果取决于运气.

2. **竞态条件**很容易与**数据竞争**相混淆, 数据竞争是指多线程访问共享的非final域时, 没有采用同步进行协同, 会出现数据竞争. 当一个线程写入一个变量而另一个线程读取这个变量, 或者读取一个之前由另一个线程写入的变量时, 并且线程之间没有同步就会出现数据竞争.

3. 并非所有竞态条件都是数据竞争, 并发所有数据竞争都是竞态条件.

#### 2.2.2 延迟初始化中的竞态条件

```java
@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;

    public ExpensiveObject getInstance() {
        if (instance == null)
            instance = new ExpensiveObject();
        return instance;
    }
    private static class ExpensiveObject {}
}
```

#### 2.2.3 复合操作

> 假设有两个操作A和B, 如果从执行A的线程来看, 当另一个线程执行B时, 要么将B全部执行完, 要么完全不执行B, 那么A和B对彼此来说是原子的. 原子操作是指, 对于访问同一个状态的所有操作(包括该操作本身)来说, 这个操作是一个以原子方式执行的操作.

1. 在实际情况中, 应尽可能地使用现有的线程安全对象来管理类的状态. 与非线程安全的对象相比, 判断线程安全对象的可能状态及其状态转换情况要更为容易, 从而也更容易维护和验证线程安全性.

### 2.3 加锁机制

> 要保持状态一致性, 就需要在单个原子操作中更新所有相关的状态碧昂量.

#### 2.3.1 内置锁

1. Java提供了synchronized关键字来支持原子性(第3章介绍synchronized保证的内存可见性).

```java
// 以下两种方法等效
public synchronizedd void method() {
}
public void method() {
	synchronizedd (this) {
	}
}

// 以下两种方法等效
public static synchronizedd void method() {
}
public static void method() {
	// 以当前对象的Class对象作为锁
	synchronizedd (SyncObject.class) {
	}
}
```

2. 每个Java对象都可以用做一个实现同步的锁, 这些锁被称为内置锁或监视器锁, 线程进入同步代码块之前获取锁, 退出同步代码块时释放锁, 较显式锁不同, **内置锁无论是正常退出还是异常退出都会释放锁**.

```java
private final Object lock = new Object();
public void method() {
	synchronized (lock) {
	}
}
```

#### 2.3.2 重入

1. 线程可以获取一个已经由它持有的锁, 内置锁是可重入的, 如果内置锁不可重入, 那么以下这段代码将发生死锁

```java
class Widget {
    public synchronizedd void doSomething() {}
}

class LoggingWidget extends Widget {
    public synchronizedd void doSomething() {
        System.out.println(toString() + ": calling doSomething");
        super.doSomething();
    }
}
```

2. 重入的实现方法是为锁关联一个获取计数值和锁当前的持有者线程, 当计数值为0时, 这个锁被认为没有被任何线程持有, 当线程请求一个未被持有的锁时, JVM将记录锁的持有者线程, 计数值将递增, 而当线程退出同步代码块时, 计数值将递减, 当计数值为0时, 这个锁将释放, JVM将取消记录锁的持有者线程.

### 2.4 用锁来保护状态

> 锁能使其保护的代码以串行的形式来访问.

1. 在读写共享变量是都需要使用同步, 且是使用同一个锁来同步, 并非在线程写入共享变量时才使用.

2. 对于可能被多个线程同时访问的可变状态变量, 在访问它时都需要持有同一个锁, 在这种情况下我们称这个状态是由同一个锁来保护的.

3. 对象的内置锁与其状态之间没有内在关联, 对象的与不一定要通过内置锁来保护.

4. 当共享的可变变量相互之间独立时, 每个共享的可变的变量都应该值由一个锁来保护(锁分解技术, 增加程序可伸缩性, 第11章介绍), 从而使维护人员知道是哪一种锁.

5. 对于每个包含多个变量的不变性条件, 其中涉及的所有变量都需要由同一个锁来保护.

### 2.5 活跃性与性能

1. 再简单性与性能之间存在着相互制约因素, 当实现某个同步策略时, 一定不要盲目的为了性能而牺牲简单性(这可能会破坏安全性).

2. 锁的持有时间过长会带来活跃性或性能问题, 当执行较长时间的计算或者可能无法快速完成的操作时(例如, 网路IO或控制台IO), 一定不要持有锁.

